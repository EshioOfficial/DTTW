<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Don't Touch The Wall ‚Äî Rertrowave Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
:root{
  --bg-dark:#081021;
  --neon-pink:#ff2d95;
  --neon-cyan:#00ffd5;
  --muted:#9aa6ad;
  --flat-low:#12002a;
}
html,body{height:100%;margin:0;font-family:Share Tech Mono,Orbitron,monospace;background:var(--bg-dark);color:#fff;overflow:hidden}
#gameWrap{display:flex;align-items:center;justify-content:center;height:100%;position:relative;z-index:1}
canvas#c{display:block;border-radius:12px;box-shadow:0 18px 50px rgba(0,0,0,.65);touch-action:none;background:transparent}
.ui{position:fixed;left:14px;top:14px;font-weight:700;letter-spacing:1px;text-shadow:0 0 10px rgba(0,255,213,.08);z-index:3}
.ui .score{font-size:18px;color:var(--neon-cyan);display:block;font-family:Orbitron,Share Tech Mono,monospace}
.ui .small{font-size:12px;color:var(--muted);font-weight:600}
.centerMsg{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;z-index:60}
button.primary{background:linear-gradient(90deg,var(--neon-pink),var(--neon-cyan));border:none;color:#031018;padding:10px 16px;border-radius:12px;font-weight:900;cursor:pointer;margin:6px 0;box-shadow:0 6px 16px rgba(139,92,255,.12)}
.footerNote{position:fixed;right:14px;bottom:10px;color:var(--muted);font-size:12px;z-index:3}
.scanlines{pointer-events:none;position:fixed;left:0;top:0;width:100%;height:100%;mix-blend-mode:overlay;z-index:5}
.scanlines::after{content:"";position:absolute;left:0;top:0;width:100%;height:100%;background:repeating-linear-gradient(0deg,rgba(0,0,0,0.03) 0,rgba(255,255,255,0.02) 2px);opacity:0.16}
.shield-icon{width:14px;height:14px;border-radius:50%;display:inline-block;margin-right:6px;vertical-align:middle}
.power-hud{margin-top:6px}
@media (max-width:600px){ .ui .score{font-size:16px} button.primary{padding:8px 12px} }
</style>
</head>
<body>
<div id="gameWrap"><canvas id="c"></canvas></div>

<div class="ui">
  <div class="score" id="score">0</div>
  <div class="score" id="diamonds">–ê–ª–º–∞–∑—ã: 0</div>
  <div class="small" id="best">Best: 0</div>
  <div id="powerHud" class="score power-hud"></div>
</div>

<div class="centerMsg" id="overlay" style="display:none"></div>

<div class="footerNote">ver.Alpha 0.3 Retrowave Edition. </div>
<div class="scanlines"></div>

<script>
/* Final v2.2 ‚Äî shield + smooth waves + stable RAF */
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
let W=0,H=0,scale=1,centerOffset=0;

const params = {
  shipX:140, shipRadius:12,
  gravity:1100, flapImpulse:350, maxFallSpeed:900,
  baseSpeed:220, speedIncrease:5,
  segWidth:28, initialGap:160, minGap:100, centerYDeltaMax:20, smoothStartTime:2.0
};

let running=false, paused=false, dead=false;
let ship={y:0,vy:0};
let tunnel=[], diamonds=[], particles=[], diamondParticles=[];
let speed=params.baseSpeed, score=0, best=0, diamondsCollected=0, diamondsTotal=0;
let lastTime=null, lastDiamondSegment=0;

let autopilotActive=false, autopilotTime=0, autopilotOscillationPhase=0;
const AUTOPILOT_DURATION=15, ATTRACT_RADIUS=200, AUTOPILOT_AMPLITUDE_FACTOR=0.15;

let wavePhase = 0, waveSpeed = 1.4;

/* Shield */
let shieldActive=false, shieldCharges=0, shieldPulse=0;
const SHIELD_MAX=3, SHIELD_COST=80;

/* RAF control */
let gameLoopId = null;

/* HUD elems */
const overlay = document.getElementById('overlay'),
      scoreEl = document.getElementById('score'),
      diamondsEl = document.getElementById('diamonds'),
      bestEl = document.getElementById('best'),
      powerHud = document.getElementById('powerHud');

let audioCtx=null;
try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx=null; }
function beep(freq,time=0.06,type='sine'){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=0.0001; o.connect(g); g.connect(audioCtx.destination); const now=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(0.12, now+0.004); g.gain.exponentialRampToValueAtTime(0.0001, now+time); o.start(now); o.stop(now+time+0.02); }

/* load saved */
try{ best = Number(localStorage.getItem('dttw_best')||0); bestEl.textContent='Best: '+best;}catch(e){}
try{ diamondsTotal = Number(localStorage.getItem('dttw_diamonds')||0); diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal;}catch(e){}

/* responsive */
function resize(){
  W = canvas.width = Math.max(360, Math.min(window.innerWidth,1400));
  H = canvas.height = Math.max(360, window.innerHeight);
  canvas.style.width='100%'; canvas.style.height='100%';
  centerOffset = H/2;
  scale = Math.min(W/900, H/700);
  params.shipRadius = 12 * scale;
  params.segWidth = 28 * scale;
  params.initialGap = 160 * scale;
  params.minGap = 100 * scale;
  params.centerYDeltaMax = 20 * scale;
  params.flapImpulse = 350 * scale;
  params.gravity = 1100 * scale;
  params.baseSpeed = 220 * scale;
  params.speedIncrease = 5 * scale;
}
window.addEventListener('resize', resize); resize();

/* input */
function flap(){ if(!running || paused || dead || autopilotActive) return; ship.vy = -params.flapImpulse; beep(800,0.08,'square'); }
window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); flap(); } if(e.key==='Escape'){ paused = !paused; overlay.style.display = paused ? 'block' : 'none'; if(paused) overlay.innerHTML = '<h2 style="color:var(--neon-cyan)">Paused</h2><div class=\"small\">Press Esc to resume</div>'; }});
canvas.addEventListener('mousedown', flap);
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});

/* gfx detection/settings (keeps options but simple) */
let gfxQuality = localStorage.getItem('dttw_gfx') || 'auto';
let recommendedQuality = null;
let gfxDetected = 'high';
const gfxSettings = {
¬† high:¬† ¬†{ particles:true, shadows:true, waves:true, diamondSpin:true, bgGradient:true, maxParticles:280, lines:8, iStep:1 },
¬† medium: { particles:true, shadows:false, waves:true, diamondSpin:true, bgGradient:true, maxParticles:150, lines:6, iStep:1 },
¬† low:¬† ¬† { particles:true, shadows:false, waves:true, diamondSpin:false, bgGradient:false, maxParticles:80, lines:4, iStep:3 }
};
function detectByHardware(){
  const cores = navigator.hardwareConcurrency || 2;
  const ua = navigator.userAgent || '';
  const isMobile = /Mobile|Android|iPhone|iPad/i.test(ua);
  gfxDetected='high';
  if(isMobile || cores <= 4) gfxDetected='medium';
  if(isMobile && cores <= 2) gfxDetected='low';
  recommendedQuality = gfxDetected;
  if(gfxQuality==='auto') gfxQuality = recommendedQuality;
  try{ localStorage.setItem('dttw_gfx', gfxQuality);}catch(e){}
}
function probeFPS(cb){
  const s=[]; let last=performance.now(), frames=0;
  function step(t){ const dt = t-last; last=t; s.push(dt); frames++; if(frames<8) requestAnimationFrame(step); else { const avg = s.reduce((a,b)=>a+b,0)/s.length; cb(1000/avg); } }
  requestAnimationFrame(step);
}

/* loading -> menu */
function showLoadingScreen(){
  detectByHardware();
  const loading = document.createElement('div'); loading.id='loadingScreen';
  loading.style.cssText='position:fixed;left:0;top:0;width:100%;height:100%;background:radial-gradient(circle at 30% 20%, #060018 0%, #02010a 60%);display:flex;align-items:center;justify-content:center;flex-direction:column;color:#00ffd5;font-family:Share Tech Mono,monospace;z-index:100';
  loading.innerHTML = '<div style="font-size:18px;letter-spacing:2px;color:#9aa6ad">[ BOOT SEQUENCE... ]</div><div id="loadingLine" style="margin-top:12px;color:var(--neon-pink)">–û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –≥—Ä–∞—Ñ–∏–∫–∏...</div><div class="loading-note" style="margin-top:14px;color:#fff">–≠—Ç–æ –∑–∞–π–º—ë—Ç —Å–µ–∫—É–Ω–¥—É</div>';
  document.body.appendChild(loading);
  overlay.style.display='none';
  probeFPS((fps)=>{
    let rec = gfxDetected;
    if(fps < 35) rec='low'; else if(fps < 55) rec='medium'; else rec='high';
    const ua = navigator.userAgent||''; if(/Mobile|Android|iPhone|iPad/i.test(ua)){ if(rec==='high') rec='medium'; else if(rec==='medium') rec='low'; }
    recommendedQuality = rec;
    const loadingLine = document.getElementById('loadingLine');
    if(loadingLine) loadingLine.innerHTML = `–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è: <span style="color:var(--neon-pink);font-weight:900">${rec==='low'?'–ù–∏–∑–∫–∞—è':rec==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è'}</span>`;
    if(gfxQuality==='auto') gfxQuality = recommendedQuality;
    try{ localStorage.setItem('dttw_gfx', gfxQuality);}catch(e){}
    const proceed = ()=>{ loading.style.transition='opacity .4s'; loading.style.opacity='0'; setTimeout(()=>{ if(loading && loading.parentNode) loading.parentNode.removeChild(loading); },420); showMainMenu(); };
    document.addEventListener('keydown', proceed, {once:true}); document.addEventListener('mousedown', proceed, {once:true}); document.addEventListener('touchstart', proceed, {once:true});
    setTimeout(proceed,1000);
  });
}

/* Menus */
function showMainMenu(){
  overlay.style.display='block';
  overlay.innerHTML = `<h1 style="margin:0 0 12px;font-family:Orbitron,Share Tech Mono,monospace;color:var(--neon-pink);text-shadow:0 0 20px rgba(255,45,149,.2)">Don't Touch The Wall</h1>
    <div class="small" style="margin-bottom:10px;color:var(--muted)">Tap / Click / Space ‚Äî flap ¬∑ Esc ‚Äî pause</div>
    <div style="display:flex;flex-direction:column;align-items:center">
      <button class="primary" id="startBtn">–ò–≥—Ä–∞—Ç—å</button>
      <button class="primary" id="boostersBtn">–ë—É—Å—Ç–µ—Ä—ã</button>
      <button class="primary" id="graphicsBtn">–ì—Ä–∞—Ñ–∏–∫–∞</button>
    </div>`;
  document.getElementById('startBtn').addEventListener('click', ()=>{ overlay.style.display='none'; reset(); startGame(); }, {once:true});
  document.getElementById('boostersBtn').addEventListener('click', showBoostersMenu);
  document.getElementById('graphicsBtn').addEventListener('click', showGraphicsMenu);
}

function showBoostersMenu(){
    overlay.style.display='block';
    overlay.innerHTML = `
        <h2 style="color:var(--neon-cyan);margin:0 0 12px">–ë—É—Å—Ç–µ—Ä—ã</h2>
        <div class="small" style="margin-bottom:12px;color:var(--muted)">–í—ã–±–µ—Ä–∏—Ç–µ –±—É—Å—Ç–µ—Ä</div>

        <div style="display:flex;flex-direction:column;align-items:center;gap:10px">
            <button class="primary" id="autopilotBtn" style="margin:0;">–ê–≤—Ç–æ–ø–∏–ª–æ—Ç ‚Äî 50 –∞–ª–º–∞–∑–æ–≤</button>
            <button class="primary" id="shieldBtn" style="margin:0;">üõ° –°–∏–ª–æ–≤–æ–µ –ø–æ–ª–µ ‚Äî ${SHIELD_COST} –∞–ª–º–∞–∑–æ–≤</button>
        </div>

        <button class="primary" id="backBtn" style="margin-top:12px;">–ù–∞–∑–∞–¥</button>
    `;

    document.getElementById('autopilotBtn').addEventListener('click', ()=>{ 
        if(shieldActive){ alert('–î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ —â–∏—Ç —Å–Ω–∞—á–∞–ª–∞.'); return; } 
        activateAutopilot(); 
    });

    document.getElementById('shieldBtn').addEventListener('click', ()=>{ 
        if(autopilotActive){ 
            alert('–î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –∞–≤—Ç–æ–ø–∏–ª–æ—Ç —Å–Ω–∞—á–∞–ª–∞.'); 
            return; 
        } 
        activateShield();
        if (running && !dead) { 
            overlay.style.display = 'none'; 
        }
    });

    document.getElementById('backBtn').addEventListener('click', showMainMenu, {once:true});
}


function showGraphicsMenu(){
  overlay.style.display='block';
  const rec = recommendedQuality ? (recommendedQuality==='low'?'–ù–∏–∑–∫–∞—è':recommendedQuality==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è') : '‚Äî';
  const cur = gfxQuality ? (gfxQuality==='auto'?'–ê–≤—Ç–æ':gfxQuality==='low'?'–ù–∏–∑–∫–∞—è':gfxQuality==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è') : '‚Äî';
  overlay.innerHTML = `<h2 style="color:var(--neon-cyan);margin:0 0 8px">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∏</h2>
    <div class="small" style="margin-bottom:12px;color:var(--muted)">–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è: <span id="recLabel" style="color:var(--neon-pink);font-weight:900">${rec}</span><br>–¢–µ–∫—É—â–∏–π: <span id="curLabel" style="color:var(--neon-cyan);font-weight:900">${cur}</span></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:6px">
      <button class="primary" id="gfxAuto">–ê–≤—Ç–æ</button>
      <button class="primary" id="gfxLow">–ù–∏–∑–∫–∞—è</button>
      <button class="primary" id="gfxMed">–°—Ä–µ–¥–Ω—è—è</button>
      <button class="primary" id="gfxHigh">–í—ã—Å–æ–∫–∞—è</button>
    </div>
    <div style="height:10px"></div>
    <div class="small opt-desc" style="color:var(--muted)">–ù–∏–∑–∫–∞—è ‚Äî –º–∞–∫—Å–∏–º—É–º FPS (–ø–ª–æ—Å–∫–∏–π —Ñ–æ–Ω, –ø—Ä–æ—Å—Ç—ã–µ –≤–æ–ª–Ω—ã, —Ç–µ–Ω–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã)</div>
    <div style="height:10px"></div>
    <button class="primary" id="gfxBack">–ù–∞–∑–∞–¥</button>`;
  document.getElementById('gfxBack').addEventListener('click', showMainMenu, {once:true});
  document.getElementById('gfxAuto').addEventListener('click', ()=>{ gfxQuality='auto'; try{ localStorage.setItem('dttw_gfx','auto'); }catch(e){}; applyAuto(); updateGfxLabels(); });
  document.getElementById('gfxLow').addEventListener('click', ()=>{ gfxQuality='low'; try{ localStorage.setItem('dttw_gfx','low'); }catch(e){}; notify('–ù–∏–∑–∫–∞—è'); updateGfxLabels(); });
  document.getElementById('gfxMed').addEventListener('click', ()=>{ gfxQuality='medium'; try{ localStorage.setItem('dttw_gfx','medium'); }catch(e){}; notify('–°—Ä–µ–¥–Ω—è—è'); updateGfxLabels(); });
  document.getElementById('gfxHigh').addEventListener('click', ()=>{ gfxQuality='high'; try{ localStorage.setItem('dttw_gfx','high'); }catch(e){}; notify('–í—ã—Å–æ–∫–∞—è'); updateGfxLabels(); });
}
function updateGfxLabels(){ const recLabel=document.getElementById('recLabel'); const curLabel=document.getElementById('curLabel'); if(recLabel) recLabel.textContent = recommendedQuality ? (recommendedQuality==='low'?'–ù–∏–∑–∫–∞—è':recommendedQuality==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è') : '‚Äî'; if(curLabel) curLabel.textContent = gfxQuality ? (gfxQuality==='auto'?'–ê–≤—Ç–æ':gfxQuality==='low'?'–ù–∏–∑–∫–∞—è':gfxQuality==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è') : '‚Äî'; }
function notify(t){ const n=document.createElement('div'); n.style.cssText='position:fixed;left:50%;top:12%;transform:translateX(-50%);background:rgba(3,16,24,0.9);padding:10px 16px;border-radius:10px;color:#00ffd5;z-index:200'; n.textContent='–í—ã–±—Ä–∞–Ω —É—Ä–æ–≤–µ–Ω—å –≥—Ä–∞—Ñ–∏–∫–∏: '+t; document.body.appendChild(n); setTimeout(()=>{ n.style.transition='opacity .4s'; n.style.opacity=0; setTimeout(()=>n.remove(),420); },1200); }
function applyAuto(){ detectByHardware(); probeFPS((fps)=>{ let rec=gfxDetected; if(fps<35) rec='low'; else if(fps<55) rec='medium'; else rec='high'; const ua=navigator.userAgent||''; if(/Mobile|Android|iPhone|iPad/i.test(ua)){ if(rec==='high') rec='medium'; else if(rec==='medium') rec='low'; } recommendedQuality = rec; if(gfxQuality==='auto') gfxQuality = recommendedQuality; try{ localStorage.setItem('dttw_gfx',gfxQuality);}catch(e){}; notify((recommendedQuality==='low'?'–ù–∏–∑–∫–∞—è':recommendedQuality==='medium'?'–°—Ä–µ–¥–Ω—è—è':'–í—ã—Å–æ–∫–∞—è')); updateGfxLabels(); }); }

/* Boosters: autopilot and shield */
/* IMPORTANT: for shield, ensure activation happens AFTER reset when starting from menu */
function activateAutopilot(){
  if(shieldActive){ alert('–î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ —â–∏—Ç —Å–Ω–∞—á–∞–ª–∞.'); return; }
  if(diamondsTotal < 50){ alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤'); return; }
  diamondsTotal -= 50; try{ localStorage.setItem('dttw_diamonds', diamondsTotal);}catch(e){}; diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal;
  autopilotActive = true; autopilotTime = AUTOPILOT_DURATION; autopilotOscillationPhase = 0;
  overlay.style.display='none';
  if(!running){ reset(); startGame(); } else updatePowerHud();
}

function activateShield(){
  if(autopilotActive){ alert('–î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –∞–≤—Ç–æ–ø–∏–ª–æ—Ç —Å–Ω–∞—á–∞–ª–∞.'); return; }
  if(shieldActive){ alert('–°–∏–ª–æ–≤–æ–µ –ø–æ–ª–µ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–æ.'); return; }
  if(diamondsTotal < SHIELD_COST){ alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–º–∞–∑–æ–≤'); return; }

  diamondsTotal -= SHIELD_COST;
  try{ localStorage.setItem('dttw_diamonds', diamondsTotal);}catch(e){}
  diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal;

  // If game not running, reset first, then enable shield (to avoid reset clearing it)
  if(!running){
    reset();
    // enable shield AFTER reset
    shieldActive = true;
    shieldCharges = SHIELD_MAX;
    shieldPulse = 0;
    startGame();
  } else {
    shieldActive = true;
    shieldCharges = SHIELD_MAX;
    shieldPulse = 0;
    overlay.style.display='none';
    updatePowerHud();
  }
}

/* clear shield helper */
function clearShield(){
  shieldActive = false;
  shieldCharges = 0;
  shieldPulse = 0;
  updatePowerHud();
}

/* shield hit + bounce */
function shieldTakeHit(hitTop){
  if(!shieldActive) return;
  shieldCharges = Math.max(0, shieldCharges - 1);
  shieldPulse = 0.36;
  beep(260,0.12,'square');
  createExplosion(params.shipX, ship.y, 'rgba(255,255,180,0.95)');
  const bounceSpeed = Math.abs(params.flapImpulse) * 0.6;
  if(hitTop){
    ship.vy = bounceSpeed;
    ship.y = Math.min(ship.y + 6*scale, H - params.shipRadius - 10);
  } else {
    ship.vy = -bounceSpeed;
    ship.y = Math.max(ship.y - 6*scale, params.shipRadius + 10);
  }
  updatePowerHud();
  if(shieldCharges <= 0){
    shieldActive = false;
    const n=document.createElement('div'); n.style.cssText='position:fixed;left:50%;top:14%;transform:translateX(-50%);background:rgba(3,16,24,0.9);padding:8px 12px;border-radius:8px;color:#ff9a9a;z-index:200'; n.textContent='–°–∏–ª–æ–≤–æ–µ –ø–æ–ª–µ –∏—Å—á–µ—Ä–ø–∞–Ω–æ'; document.body.appendChild(n);
    setTimeout(()=>{ n.style.transition='opacity .4s'; n.style.opacity=0; setTimeout(()=>n.remove(),420); },900);
    updatePowerHud();
  }
}

/* HUD update */
function updatePowerHud(){
  powerHud.innerHTML = '';
  if(autopilotActive){
    powerHud.textContent = '–ê–≤—Ç–æ–ø–∏–ª–æ—Ç: ' + Math.ceil(Math.max(0,autopilotTime)) + 's';
    return;
  }
  if(shieldActive){
    for(let i=0;i<SHIELD_MAX;i++){
      const s = document.createElement('span'); s.className='shield-icon';
      if(i < shieldCharges){
        s.style.background = 'radial-gradient(circle at 30% 30%, rgba(0,255,213,0.95), rgba(0,255,213,0.25))';
        s.style.boxShadow = '0 0 10px rgba(0,255,213,0.55)';
      } else {
        s.style.background = 'rgba(10,10,10,0.22)'; s.style.boxShadow='none';
      }
      powerHud.appendChild(s);
    }
    return;
  }
  powerHud.innerHTML = '';
}

/* Game core */
function reset(){
  stopLoop();
  ship = { y: centerOffset, vy: 0 };
  tunnel.length = 0; diamonds.length = 0; particles.length = 0; diamondParticles.length = 0;
  diamondsCollected = 0; score = 0; speed = params.baseSpeed; dead = false; lastTime = null; lastDiamondSegment = 0;
  scoreEl.textContent='0'; diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal;
  const smoothStartSegments = Math.ceil((params.baseSpeed * params.smoothStartTime) / params.segWidth);
  const segs = Math.ceil((W + 200) / params.segWidth);
  let cy = centerOffset;
  for(let i=0;i<segs;i++){
    let delta = 0;
    if(i > smoothStartSegments/2){
      const factor = Math.min(1, (i - smoothStartSegments/2) / (smoothStartSegments/2));
      delta = (Math.random()*2 - 1) * params.centerYDeltaMax * factor;
    }
    cy += delta; cy = clampTunnel(cy, params.initialGap); tunnel.push({ x: i*params.segWidth, centerY: cy });
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0; ctx.shadowColor='transparent';
  // DO NOT clear shield here ‚Äî shield activation should survive if set AFTER reset.
  // clearShield(); <-- intentionally not called
}

/* spawn */
function spawnSegment(){
  if(dead) return;
  const last = tunnel[tunnel.length-1];
  let delta = (Math.random()*2 - 1) * params.centerYDeltaMax;
  let cy = last.centerY + delta; cy = clampTunnel(cy, params.initialGap);
  tunnel.push({ x: last.x + params.segWidth, centerY: cy });
  lastDiamondSegment++;
  if(lastDiamondSegment >= 20 && Math.random() < 0.35){
    diamonds.push({ x: last.x + params.segWidth, y: cy });
    lastDiamondSegment = 0;
  }
}

/* die */
function die(){
  if(dead) return;
  createExplosion(params.shipX, ship.y, 'rgba(0,255,213,0.95)');
  dead = true; running = false;
  stopLoop();
  beep(120,0.6,'sawtooth');
  overlay.style.display='block';
  overlay.innerHTML = `<h2 style="margin:0 0 12px;color:var(--neon-pink)">Game Over</h2>
    <div class="small" style="margin-bottom:14px;color:var(--muted)">Score: ${Math.floor(score)}</div>
    <div class="small" style="margin-bottom:14px;color:var(--muted)">Diamonds: ${diamondsCollected}</div>
    <button class="primary" id="tryBtn">Try Again</button>
    <button class="primary" id="boostersAfterBtn">–ë—É—Å—Ç–µ—Ä—ã</button>
    <div style="height:8px"></div>
    <div class="small">Best: ${best}</div>`;
  document.getElementById('tryBtn').addEventListener('click', ()=>{ overlay.style.display='none'; reset(); startGame(); }, {once:true});
  document.getElementById('boostersAfterBtn').addEventListener('click', showBoostersMenu);
  if(Math.floor(score) > best){ best = Math.floor(score); try{ localStorage.setItem('dttw_best', best);}catch(e){} }
  bestEl.textContent = 'Best: ' + best;
}

/* Particles */
function createExplosion(x,y,color){
  if(!gfxSettings[gfxQuality].particles) return;
  const cap = gfxSettings[gfxQuality].maxParticles || 120;
  const free = Math.max(0, cap - (particles.length + diamondParticles.length));
  const toSpawn = Math.min(25, free);
  for(let i=0;i<toSpawn;i++){ const angle=Math.random()*Math.PI*2; const s=60+Math.random()*120; particles.push({ x,y,vx:Math.cos(angle)*s, vy:Math.sin(angle)*s, life:1, color }); }
}
function createDiamondParticles(x,y){
  if(!gfxSettings[gfxQuality].particles) return;
  const cap = gfxSettings[gfxQuality].maxParticles || 120;
  const free = Math.max(0, cap - (particles.length + diamondParticles.length));
  const toSpawn = Math.min(10, free);
  for(let i=0;i<toSpawn;i++){ const angle=Math.random()*Math.PI*2; const s=20+Math.random()*50; diamondParticles.push({ x,y,vx:Math.cos(angle)*s, vy:Math.sin(angle)*s, life:0.6+Math.random()*0.6, color:'gold' }); }
}
function updateParticles(dt,arr){ arr.forEach(p=>{ p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 200*dt; p.life -= dt*1.2; }); return arr.filter(p=>p.life>0); }
function drawParticles(){
  if(!gfxSettings[gfxQuality].particles) return;
  const useShadows = gfxSettings[gfxQuality].shadows;
  for(let p of particles){
    ctx.save(); ctx.globalAlpha = Math.max(0,p.life); ctx.beginPath(); ctx.arc(p.x,p.y,3*scale,0,Math.PI*2); ctx.fillStyle=p.color;
    if(useShadows){ ctx.shadowColor=p.color; ctx.shadowBlur=8; } else { ctx.shadowBlur=0; ctx.shadowColor='transparent'; }
    ctx.fill(); ctx.restore();
  }
  for(let p of diamondParticles){
    ctx.save(); ctx.globalAlpha = Math.max(0,p.life); ctx.beginPath(); ctx.arc(p.x,p.y,3*scale,0,Math.PI*2); ctx.fillStyle=p.color;
    if(useShadows){ ctx.shadowColor=p.color; ctx.shadowBlur=8; } else { ctx.shadowBlur=0; ctx.shadowColor='transparent'; }
    ctx.fill(); ctx.restore();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0; ctx.shadowColor='transparent';
}

/* Update with delta-time */
function update(dt){
  // wave uses dt => smooth independent of FPS
  // for low gfx, we'll slow waveSpeed and amplitude below in draw

  particles = updateParticles(dt, particles);
  diamondParticles = updateParticles(dt, diamondParticles);

  if(shieldPulse > 0) shieldPulse = Math.max(0, shieldPulse - dt);

  if(!running || paused || dead) return;

  let logicalShipX = params.shipX;

  if(autopilotActive){
    autopilotOscillationPhase += dt * 6;
    let i=0; while(i < tunnel.length-1 && tunnel[i+1].x < logicalShipX) i++;
    const a=tunnel[i], b=tunnel[i+1]||a; const t=(logicalShipX - a.x)/(b.x - a.x || 1);
    const centerY = a.centerY + (b.centerY - a.centerY) * t;
    const gap = params.initialGap; const amplitude = gap * AUTOPILOT_AMPLITUDE_FACTOR;
    ship.y += ((centerY + Math.sin(autopilotOscillationPhase)*amplitude) - ship.y) * dt * 6;
    speed = params.baseSpeed * 6;

    for(let j=diamonds.length-1;j>=0;j--){ const d=diamonds[j]; const dx=d.x-logicalShipX; const dy=d.y-ship.y; const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist < ATTRACT_RADIUS){ d.x += -dx * dt * 15; d.y += -dy * dt * 15; }
      if(dist < params.shipRadius + 10){ diamondsCollected++; diamondsTotal++; try{ localStorage.setItem('dttw_diamonds', diamondsTotal);}catch(e){}; diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal; createDiamondParticles(d.x,d.y); beep(1200,0.05,'square'); diamonds.splice(j,1); }
    }
    autopilotTime -= dt; if(autopilotTime <= 0) autopilotActive = false;
    updatePowerHud();
  } else {
    ship.vy += params.gravity * dt; ship.vy = Math.min(ship.vy, params.maxFallSpeed); ship.y += ship.vy * dt;
    speed = params.baseSpeed + Math.floor(score/100) * params.speedIncrease;
    for(let j=diamonds.length-1;j>=0;j--){ const d=diamonds[j]; const dx=d.x-logicalShipX; const dy=d.y-ship.y; if(Math.sqrt(dx*dx+dy*dy) < params.shipRadius + 10){ diamondsCollected++; diamondsTotal++; try{ localStorage.setItem('dttw_diamonds', diamondsTotal);}catch(e){}; diamondsEl.textContent='–ê–ª–º–∞–∑—ã: '+diamondsTotal; createDiamondParticles(d.x,d.y); beep(1200,0.05,'square'); diamonds.splice(j,1); } }
  }

  const dx = speed * dt;
  for(let s of tunnel) s.x -= dx;
  while(tunnel.length && tunnel[0].x < -params.segWidth) tunnel.shift();
  while(tunnel.length < Math.ceil((W+200)/params.segWidth)) spawnSegment();

  for(let d of diamonds) d.x -= dx;
  diamonds = diamonds.filter(d => d.x > -20);

  score += dx * 0.1; scoreEl.textContent = Math.floor(score);

  // collision detection
  let i=0; let logicalShipX2 = params.shipX;
  while(i < tunnel.length-1 && tunnel[i+1].x < logicalShipX2) i++;
  const a=tunnel[i]||tunnel[0], b=tunnel[i+1]||a; const tt=(logicalShipX2 - a.x)/(b.x - a.x || 1);
  const centerY = a.centerY + (b.centerY - a.centerY) * tt;
  const gap = params.initialGap; const topY = centerY - gap/2; const botY = centerY + gap/2;

  if(!autopilotActive){
    if(!dead && (ship.y - params.shipRadius < topY || ship.y + params.shipRadius > botY)){
      if(shieldActive){
        const hitTop = (ship.y - params.shipRadius < topY);
        shieldTakeHit(hitTop);
        if(hitTop) ship.y = topY + params.shipRadius + 4*scale;
        else ship.y = botY - params.shipRadius - 4*scale;
      } else {
        die();
      }
    }
  }

  if(autopilotActive){
    powerHud.textContent = '–ê–≤—Ç–æ–ø–∏–ª–æ—Ç: ' + Math.ceil(Math.max(0,autopilotTime)) + 's';
  } else {
    updatePowerHud();
  }
}

/* Draw */
function draw(){
¬† // –†–∞—Å—á–µ—Ç —Ñ–∞–∑—ã –≤–æ–ª–Ω—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ (Date.now()) –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
¬† const globalTime = Date.now() / 1000;
¬† wavePhase = globalTime * waveSpeed * 2.0; 
¬† 
¬† ctx.save(); ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
¬† if(gfxSettings[gfxQuality].bgGradient){
¬† ¬† const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#060022'); g.addColorStop(0.6,'#160533'); g.addColorStop(1,'#081021'); ctx.fillStyle=g;
¬† } else {
¬† ¬† ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--flat-low') || '#12002a';
¬† }
¬† ctx.fillRect(0,0,W,H); ctx.restore();

¬† // waves/tunnel:
¬† const lines = gfxSettings[gfxQuality].lines || 6;
¬† const drawStep = 1; 
¬† const lowOrMedium = (gfxQuality === 'low' || gfxQuality === 'medium'); // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: Medium –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ—Å—Ç—É—é —Ñ–æ—Ä–º—É–ª—É –≤–æ–ª–Ω
¬† ctx.strokeStyle = 'rgba(0,255,213,0.09)'; ctx.lineWidth = 2;
¬† for(let j=0;j<lines;j++){
¬† ¬† ctx.beginPath();
¬† ¬† for(let i=0;i<tunnel.length;i+=drawStep){
¬† ¬† ¬† // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤–æ–ª–Ω: Medium –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–æ—Å—Ç—É—é —Ñ–æ—Ä–º—É–ª—É Low, —á—Ç–æ–±—ã —Å–Ω—è—Ç—å –Ω–∞–≥—Ä—É–∑–∫—É
¬† ¬† ¬† const baseOffset = lowOrMedium
¬† ¬† ¬† ¬† ? Math.sin(wavePhase*0.8 + i*0.10 + j*0.12) * 3
¬† ¬† ¬† ¬† : Math.sin(wavePhase + i*0.18 + j*0.28)*6 + Math.sin(wavePhase*0.5 + i*0.1 + j*0.15)*4;
¬† ¬† ¬† const yTop = tunnel[i].centerY - params.initialGap/2 + baseOffset + j*2;
¬† ¬† ¬† if(i===0) ctx.moveTo(tunnel[i].x,yTop); else ctx.lineTo(tunnel[i].x,yTop);
¬† ¬† }
¬† ¬† ctx.stroke();

¬† ¬† ctx.beginPath();
¬† ¬† for(let i=0;i<tunnel.length;i+=drawStep){
¬† ¬† ¬† // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤–æ–ª–Ω (cos)
¬† ¬† ¬† const baseOffset = lowOrMedium
¬† ¬† ¬† ¬† ? Math.cos(wavePhase*0.8 + i*0.10 + j*0.12) * 3
¬† ¬† ¬† ¬† : Math.cos(wavePhase + i*0.18 + j*0.28)*6 + Math.cos(wavePhase*0.5 + i*0.1 + j*0.15)*4;
¬† ¬† ¬† const yBot = tunnel[i].centerY + params.initialGap/2 + baseOffset + j*2;
¬† ¬† ¬† if(i===0) ctx.moveTo(tunnel[i].x,yBot); else ctx.lineTo(tunnel[i].x,yBot);
¬† ¬† }
¬† ¬† ctx.stroke();
¬† }

¬† drawParticles();

¬† for(let d of diamonds){
¬† ¬† ctx.save(); ctx.translate(d.x,d.y); if(gfxSettings[gfxQuality].diamondSpin) ctx.rotate((Date.now()%1000)/1000 * Math.PI * 2);
¬† ¬† // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ç–µ–Ω–∏ –∞–ª–º–∞–∑–æ–≤: —É–º–µ–Ω—å—à–∞–µ–º blur –¥–ª—è High
¬† ¬† if(gfxSettings[gfxQuality].shadows){ 
¬† ¬† ¬† ctx.shadowColor='rgba(255,215,0,0.6)'; 
¬† ¬† ¬† ctx.shadowBlur= (gfxQuality === 'high' ? 8 : 12); 
¬† ¬† } else { 
¬† ¬† ¬† ctx.shadowBlur=0; ctx.shadowColor='transparent'; 
¬† ¬† }
¬† ¬† ctx.beginPath(); ctx.moveTo(0,-10*scale); ctx.lineTo(8*scale,0); ctx.lineTo(0,10*scale); ctx.lineTo(-8*scale,0); ctx.closePath(); ctx.fillStyle='gold'; ctx.fill(); ctx.restore();
¬† }

¬† if(!dead){
¬† ¬† if(shieldActive){
¬† ¬† ¬† ctx.save();
¬† ¬† ¬† const pulseFactor = 1 + 0.15 * Math.sin(Date.now()/120) + (shieldPulse > 0 ? 0.25*(shieldPulse/0.36) : 0);
¬† ¬† ¬† const radius = 20*scale * (1 + 0.06*(SHIELD_MAX - shieldCharges)) * pulseFactor;
¬† ¬† ¬† ctx.beginPath(); ctx.arc(params.shipX, ship.y, radius, 0, Math.PI*2);
¬† ¬† ¬† ctx.fillStyle = 'rgba(0,255,213,0.06)'; ctx.fill();
¬† ¬† ¬† ctx.lineWidth = 2 + (shieldPulse > 0 ? 2 : 0);
¬† ¬† ¬† ctx.strokeStyle = shieldPulse > 0 ? 'rgba(255,240,150,0.95)' : 'rgba(0,255,213,0.45)';
¬† ¬† ¬† ctx.shadowColor = 'rgba(0,255,213,0.6)'; ctx.shadowBlur = shieldPulse > 0 ? 20 : 12;
¬† ¬† ¬† ctx.stroke();
¬† ¬† ¬† ctx.restore();
¬† ¬† ¬† ctx.shadowBlur = 0; ctx.shadowColor='transparent';
¬† ¬† }
¬† ¬† ctx.save(); ctx.translate(params.shipX, ship.y);
¬† ¬† const angle = Math.max(-0.6, Math.min(0.6, -ship.vy/600)); ctx.rotate(angle);
¬† ¬† // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ç–µ–Ω–∏ –∫–æ—Ä–∞–±–ª—è: —É–º–µ–Ω—å—à–∞–µ–º blur –¥–ª—è High
¬† ¬† if(gfxSettings[gfxQuality].shadows){ 
¬† ¬† ¬† ctx.shadowColor='rgba(0,255,213,0.25)'; 
¬† ¬† ¬† ctx.shadowBlur= (gfxQuality === 'high' ? 12 : 20); 
¬† ¬† } else { 
¬† ¬† ¬† ctx.shadowBlur=0; ctx.shadowColor='transparent'; 
¬† ¬† }
¬† ¬† ctx.beginPath(); ctx.moveTo(-14*scale,-10*scale); ctx.lineTo(16*scale,0); ctx.lineTo(-14*scale,10*scale); ctx.closePath(); ctx.fillStyle='rgba(0,255,213,0.95)'; ctx.fill();
¬† ¬† ctx.beginPath(); ctx.moveTo(-6*scale,-6*scale); ctx.lineTo(10*scale,0); ctx.lineTo(-6*scale,6*scale); ctx.closePath(); ctx.fillStyle='rgba(255,45,149,0.9)'; ctx.fill();
¬† ¬† ctx.restore();
¬† }
}

/* RAF handlers */
function loop(t){
  if(!lastTime) lastTime = t;
  const dt = Math.min(0.04, (t - lastTime) / 1000);
  lastTime = t;
  update(dt);
  draw();
  gameLoopId = requestAnimationFrame(loop);
}
function stopLoop(){
  if(gameLoopId !== null){ cancelAnimationFrame(gameLoopId); gameLoopId = null; }
  running = false;
}
function startGame(){
  if(gameLoopId !== null) return;
  running = true; paused = false; dead = false; lastTime = null;
  updatePowerHud();
  gameLoopId = requestAnimationFrame(loop);
}

/* helpers */
function clampTunnel(cy,gap){ return Math.max(gap/2+20, Math.min(H-gap/2-20, cy)); }
function ensureTunnel(){ const segs=Math.ceil((W+200)/params.segWidth); if(tunnel.length===0){ let cy=centerOffset; for(let i=0;i<segs;i++){ let delta=0; if(i>2) delta=(Math.random()*2-1)*params.centerYDeltaMax; cy+=delta; cy=clampTunnel(cy, params.initialGap); tunnel.push({ x:i*params.segWidth, centerY:cy }); } } }
ensureTunnel();

/* init */
reset();
window.addEventListener('load', ()=>{ if(gfxQuality==='auto') gfxQuality='auto'; showLoadingScreen(); });

</script>
</body>
</html>
